<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEON-TRIS ¬∑ Modern Tetris</title>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
        }

        body {
            margin: 0;
            min-height: 100vh;
            background: linear-gradient(145deg, #0b0e1a 0%, #1a1f2f 100%);
            font-family: 'Inter', 'Segoe UI', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #e0e5ff;
        }

        .game-container {
            background: rgba(10, 15, 25, 0.7);
            backdrop-filter: blur(12px);
            border: 2px solid #4a6c8f;
            border-radius: 42px;
            padding: 30px 40px;
            box-shadow: 0 25px 40px rgba(0, 20, 50, 0.8), 0 0 0 1px #6a8fc0 inset;
            display: flex;
            gap: 40px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
        }

        /* main play area */
        .play-area {
            text-align: center;
        }

        canvas#board {
            display: block;
            width: 300px;
            height: 600px;
            border-radius: 28px;
            background: #0a0f1a;
            box-shadow: 0 0 0 2px #3d5f8a, 0 20px 30px -8px black;
            image-rendering: crisp-edges;
        }

        .info-panel {
            display: flex;
            flex-direction: column;
            gap: 28px;
            min-width: 160px;
        }

        .next-piece {
            background: #0e1422;
            border-radius: 34px;
            padding: 25px 20px 20px 20px;
            border: 1px solid #4f7eb3;
            box-shadow: inset 0 0 15px #1d3145, 0 10px 20px rgba(0,0,0,0.5);
            text-align: center;
        }

        .next-piece h3 {
            margin: 0 0 18px 0;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 4px;
            font-size: 1rem;
            color: #a0c4ff;
            text-shadow: 0 0 8px cyan;
        }

        canvas#nextCanvas {
            width: 120px;
            height: 120px;
            background: #0a101c;
            border-radius: 22px;
            margin: 0 auto;
            display: block;
            box-shadow: 0 0 0 2px #3d6190;
        }

        .stats {
            background: #0e1422;
            border-radius: 34px;
            padding: 24px 22px;
            border: 1px solid #6a8fc0;
            box-shadow: inset 0 0 10px #1d2c42;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            font-size: 1.2rem;
            font-weight: 500;
            text-shadow: 0 0 5px #7aaae2;
        }

        .stat-label {
            color: #b0caf0;
        }

        .stat-value {
            color: #e3f2ff;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
        }

        .controls {
            background: #0e1422;
            border-radius: 30px;
            padding: 16px 20px;
            border: 1px solid #5f7fb0;
            font-size: 0.85rem;
            color: #b5d0ff;
            line-height: 1.8;
        }

        .controls kbd {
            background: #1e2a3a;
            border-radius: 10px;
            padding: 3px 10px;
            color: #9ad0ff;
            border: 1px solid #3d6390;
            box-shadow: 0 2px 0 #0b121f;
            font-family: monospace;
        }

        button#restart {
            background: #2a3f5a;
            border: none;
            border-radius: 50px;
            padding: 14px 28px;
            font-size: 1.3rem;
            font-weight: 600;
            color: #e0f0ff;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            box-shadow: 0 8px 0 #0d1a2a, 0 10px 20px black;
            transition: 0.08s linear;
            border: 1px solid #7aa5e0;
            margin-top: 10px;
        }

        button#restart:active {
            transform: translateY(6px);
            box-shadow: 0 2px 0 #0d1a2a, 0 5px 12px black;
        }

        .ghost-hint {
            margin-top: 10px;
            font-size: 0.8rem;
            color: #afcfff;
            letter-spacing: 1px;
        }
        .ghost-hint span {
            color: #9ae0ff;
            font-weight: 600;
        }
    </style>
</head>
<body>
<div class="game-container">
    <div class="play-area">
        <canvas id="board" width="300" height="600"></canvas>
    </div>
    <div class="info-panel">
        <div class="next-piece">
            <h3>üîÆ NEXT</h3>
            <canvas id="nextCanvas" width="120" height="120"></canvas>
        </div>
        <div class="stats">
            <div class="stat-item"><span class="stat-label">SCORE</span> <span class="stat-value" id="score">0</span></div>
            <div class="stat-item"><span class="stat-label">LINES</span> <span class="stat-value" id="lines">0</span></div>
            <div class="stat-item"><span class="stat-label">LEVEL</span> <span class="stat-value" id="level">0</span></div>
        </div>
        <div class="controls">
            <div><kbd>‚Üê</kbd> / <kbd>‚Üí</kbd> move</div>
            <div><kbd>‚Üë</kbd> rotate</div>
            <div><kbd>‚Üì</kbd> soft drop</div>
            <div><kbd>Space</kbd> hard drop</div>
            <div><kbd>R</kbd> restart</div>
        </div>
        <div class="ghost-hint">
            <span>‚ú¶ GHOST PIECE ENABLED ‚ú¶</span>
        </div>
        <button id="restart">‚Üª RESTART</button>
    </div>
</div>
<script>
    (function() {
        // ----- CONSTANTS & GLOBALS -----
        const COLS = 10;
        const ROWS = 20;
        const CELL_SIZE = 30;        // board canvas 300x600
        const NEXT_SIZE = 24;         // cell size for next canvas (120/5 ‚âà24, but we'll draw scaled)

        // Tetromino definitions (4x4 matrices)
        const SHAPES = [
            // I
            [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]],
            // O
            [[0,0,0,0], [0,1,1,0], [0,1,1,0], [0,0,0,0]],
            // T
            [[0,0,0,0], [0,1,0,0], [1,1,1,0], [0,0,0,0]],
            // S
            [[0,0,0,0], [0,1,1,0], [1,1,0,0], [0,0,0,0]],
            // Z
            [[0,0,0,0], [1,1,0,0], [0,1,1,0], [0,0,0,0]],
            // L
            [[0,0,0,0], [1,0,0,0], [1,1,1,0], [0,0,0,0]],
            // J
            [[0,0,0,0], [0,0,1,0], [1,1,1,0], [0,0,0,0]]
        ];

        const COLORS = [
            '#0d0f1c', // empty / dark
            '#3ad1f0', // I cyan
            '#f5e73d', // O yellow
            '#b484e0', // T purple
            '#5ed48a', // S green
            '#f0675f', // Z red
            '#f09a4a', // L orange
            '#4f9ef2'  // J blue
        ];

        // board representation (0 = empty)
        let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));

        // current piece
        let currentPiece = {
            shapeIdx: 0,
            matrix: [],
            x: 3,
            y: 0,
        };

        let nextShapeIdx = 0;
        let score = 0;
        let totalLines = 0;
        let level = 0;
        let gameOver = false;
        let fallInterval = 500; // ms, decreases with level
        let intervalId = null;

        // DOM elements
        const boardCanvas = document.getElementById('board');
        const ctx = boardCanvas.getContext('2d');
        const nextCanvas = document.getElementById('nextCanvas');
        const nextCtx = nextCanvas.getContext('2d');
        const scoreSpan = document.getElementById('score');
        const linesSpan = document.getElementById('lines');
        const levelSpan = document.getElementById('level');
        const restartBtn = document.getElementById('restart');

        // ----- helper functions -----
        function getRandomShapeIdx() {
            return Math.floor(Math.random() * SHAPES.length);
        }

        // create new piece from shape index
        function createPieceFromIdx(idx) {
            return {
                shapeIdx: idx,
                matrix: SHAPES[idx].map(row => [...row]), // copy
                x: 3,
                y: 0
            };
        }

        // spawn new piece using the next shape
        function spawnNewPiece() {
            currentPiece = createPieceFromIdx(nextShapeIdx);
            nextShapeIdx = getRandomShapeIdx();

            // collision at spawn? game over
            if (collision(currentPiece.matrix, currentPiece.x, currentPiece.y)) {
                gameOver = true;
                clearInterval(intervalId);
                intervalId = null;
                currentPiece = null;
            }
            drawAll();
        }

        // collision test between given matrix and board at (offX, offY)
        function collision(matrix, offX, offY) {
            for (let r = 0; r < 4; r++) {
                for (let c = 0; c < 4; c++) {
                    if (matrix[r][c] !== 0) {
                        let boardX = offX + c;
                        let boardY = offY + r;
                        if (boardX < 0 || boardX >= COLS || boardY >= ROWS || boardY < 0) return true;
                        if (boardY >= 0 && board[boardY][boardX] !== 0) return true;
                    }
                }
            }
            return false;
        }

        // merge current piece into board
        function mergePiece() {
            if (!currentPiece) return;
            for (let r = 0; r < 4; r++) {
                for (let c = 0; c < 4; c++) {
                    if (currentPiece.matrix[r][c] !== 0) {
                        let boardY = currentPiece.y + r;
                        let boardX = currentPiece.x + c;
                        if (boardY >= 0 && boardY < ROWS && boardX >= 0 && boardX < COLS) {
                            board[boardY][boardX] = currentPiece.shapeIdx + 1; // color index (1-based)
                        }
                    }
                }
            }
        }

        // clear full lines and update score
        function clearLines() {
            let linesCleared = 0;
            for (let row = ROWS - 1; row >= 0; ) {
                let full = true;
                for (let col = 0; col < COLS; col++) {
                    if (board[row][col] === 0) {
                        full = false;
                        break;
                    }
                }
                if (full) {
                    // remove row
                    for (let r = row; r > 0; r--) {
                        board[r] = [...board[r-1]];
                    }
                    board[0] = Array(COLS).fill(0);
                    linesCleared++;
                    // stay on same row index because rows shifted down
                } else {
                    row--;
                }
            }

            if (linesCleared > 0) {
                totalLines += linesCleared;
                // classic scoring
                const lineScores = [0, 40, 100, 300, 1200];
                let addScore = lineScores[linesCleared] * (level + 1);
                score += addScore;

                // update level (every 10 lines)
                level = Math.floor(totalLines / 10);
                // adjust fall interval (capped at 80ms)
                let newInterval = Math.max(80, 500 - level * 30);
                if (newInterval !== fallInterval) {
                    fallInterval = newInterval;
                    resetInterval();
                }
            }
            updateStats();
        }

        // hard drop: move down until collision, then merge & spawn
        function hardDrop() {
            if (!currentPiece || gameOver) return;
            // ghost drop: find lowest y
            let dropY = currentPiece.y;
            while (!collision(currentPiece.matrix, currentPiece.x, dropY + 1)) {
                dropY++;
            }
            currentPiece.y = dropY;
            // merge & spawn
            mergePiece();
            clearLines();
            spawnNewPiece();
            drawAll();
        }

        // move piece (dx, dy) if possible
        function movePiece(dx, dy) {
            if (!currentPiece || gameOver) return false;
            let newX = currentPiece.x + dx;
            let newY = currentPiece.y + dy;
            if (!collision(currentPiece.matrix, newX, newY)) {
                currentPiece.x = newX;
                currentPiece.y = newY;
                drawAll();
                return true;
            }
            // if move down fails (dy === 1), lock piece
            if (dy === 1) {
                mergePiece();
                clearLines();
                spawnNewPiece();
                drawAll();
            }
            return false;
        }

        // rotate piece clockwise
        function rotatePiece() {
            if (!currentPiece || gameOver) return;
            // rotate matrix 90¬∞
            let matrix = currentPiece.matrix;
            let rotated = Array(4).fill().map(() => Array(4).fill(0));
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    rotated[j][3 - i] = matrix[i][j];
                }
            }
            // kickback if collision (simple wallkick: try left/right shifts)
            if (!collision(rotated, currentPiece.x, currentPiece.y)) {
                currentPiece.matrix = rotated;
            } else {
                // try left shift once
                if (!collision(rotated, currentPiece.x - 1, currentPiece.y)) {
                    currentPiece.matrix = rotated;
                    currentPiece.x -= 1;
                }
                // try right shift once
                else if (!collision(rotated, currentPiece.x + 1, currentPiece.y)) {
                    currentPiece.matrix = rotated;
                    currentPiece.x += 1;
                }
                // (one could add more kicks, but this is fine for modern feel)
            }
            drawAll();
        }

        // ----- ghost piece: compute lowest drop position -----
        function getGhostY() {
            if (!currentPiece) return currentPiece;
            let y = currentPiece.y;
            while (!collision(currentPiece.matrix, currentPiece.x, y + 1)) {
                y++;
            }
            return y;
        }

        // ----- drawing functions -----
        function drawBoard() {
            ctx.clearRect(0, 0, 300, 600);

            // draw board cells
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    let val = board[row][col];
                    let color = COLORS[val] || '#0a0f1a';
                    ctx.fillStyle = color;
                    ctx.fillRect(col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE-1, CELL_SIZE-1);

                    // subtle grid
                    ctx.strokeStyle = '#2a3f60';
                    ctx.lineWidth = 0.5;
                    ctx.strokeRect(col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
            }

            // draw ghost piece (if game active)
            if (currentPiece && !gameOver) {
                let ghostY = getGhostY();
                if (ghostY !== currentPiece.y) {
                    ctx.globalAlpha = 0.25;
                    for (let r = 0; r < 4; r++) {
                        for (let c = 0; c < 4; c++) {
                            if (currentPiece.matrix[r][c] !== 0) {
                                let x = (currentPiece.x + c) * CELL_SIZE;
                                let y = (ghostY + r) * CELL_SIZE;
                                ctx.fillStyle = '#b0e0ff';
                                ctx.fillRect(x, y, CELL_SIZE-1, CELL_SIZE-1);
                                ctx.strokeStyle = '#ffffff';
                                ctx.strokeRect(x, y, CELL_SIZE, CELL_SIZE);
                            }
                        }
                    }
                    ctx.globalAlpha = 1.0;
                }
            }

            // draw current piece (on top)
            if (currentPiece && !gameOver) {
                for (let r = 0; r < 4; r++) {
                    for (let c = 0; c < 4; c++) {
                        if (currentPiece.matrix[r][c] !== 0) {
                            let x = (currentPiece.x + c) * CELL_SIZE;
                            let y = (currentPiece.y + r) * CELL_SIZE;
                            let colorIdx = currentPiece.shapeIdx + 1;
                            ctx.fillStyle = COLORS[colorIdx];
                            ctx.fillRect(x, y, CELL_SIZE-1, CELL_SIZE-1);
                            // subtle highlight
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 1.5;
                            ctx.strokeRect(x, y, CELL_SIZE, CELL_SIZE);
                        }
                    }
                }
            }

            // game over overlay
            if (gameOver) {
                ctx.globalAlpha = 0.6;
                ctx.fillStyle = '#0f1425';
                ctx.fillRect(0, 200, 300, 80);
                ctx.globalAlpha = 1;
                ctx.font = 'bold 22px "Inter", sans-serif';
                ctx.fillStyle = '#ff8a8a';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 16;
                ctx.fillText('GAME OVER', 28, 260);
                ctx.shadowBlur = 0;
            }
        }

        function drawNext() {
            nextCtx.clearRect(0, 0, 120, 120);
            nextCtx.fillStyle = '#0a101c';
            nextCtx.fillRect(0, 0, 120, 120);

            let matrix = SHAPES[nextShapeIdx];
            let blockSize = 24; // 120/5 approx, but we'll center
            let offsetX = (120 - (4 * blockSize)) / 2;
            let offsetY = (120 - (4 * blockSize)) / 2;

            for (let r = 0; r < 4; r++) {
                for (let c = 0; c < 4; c++) {
                    if (matrix[r][c]) {
                        let colorIdx = nextShapeIdx + 1;
                        nextCtx.fillStyle = COLORS[colorIdx];
                        nextCtx.fillRect(offsetX + c * blockSize, offsetY + r * blockSize, blockSize-1, blockSize-1);
                        nextCtx.strokeStyle = '#aac0ff';
                        nextCtx.strokeRect(offsetX + c * blockSize, offsetY + r * blockSize, blockSize, blockSize);
                    }
                }
            }
        }

        function updateStats() {
            scoreSpan.innerText = score;
            linesSpan.innerText = totalLines;
            levelSpan.innerText = level;
        }

        function drawAll() {
            drawBoard();
            drawNext();
        }

        // interval management
        function resetInterval() {
            if (intervalId) clearInterval(intervalId);
            if (!gameOver) {
                intervalId = setInterval(() => {
                    if (currentPiece && !gameOver) {
                        movePiece(0, 1);
                    }
                }, fallInterval);
            }
        }

        // restart game
        function restartGame() {
            // reset board
            board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            score = 0;
            totalLines = 0;
            level = 0;
            fallInterval = 500;
            gameOver = false;

            // random initial next and current
            nextShapeIdx = getRandomShapeIdx();
            currentPiece = createPieceFromIdx(getRandomShapeIdx());
            // but ensure next is different
            nextShapeIdx = getRandomShapeIdx();

            updateStats();
            if (intervalId) clearInterval(intervalId);
            resetInterval();
            drawAll();
        }

        // keyboard handling
        function handleKey(e) {
            const key = e.key;
            if (gameOver) {
                if (key === 'r' || key === 'R') restartGame();
                e.preventDefault();
                return;
            }

            switch (key) {
                case 'ArrowLeft':  e.preventDefault(); movePiece(-1, 0); break;
                case 'ArrowRight': e.preventDefault(); movePiece(1, 0); break;
                case 'ArrowDown':  e.preventDefault(); movePiece(0, 1); break;
                case 'ArrowUp':    e.preventDefault(); rotatePiece(); break;
                case ' ':          e.preventDefault(); hardDrop(); break;
                case 'r':
                case 'R':          restartGame(); e.preventDefault(); break;
            }
        }

        // disable page scrolling with arrows
        window.addEventListener('keydown', handleKey);

        // restart button
        restartBtn.addEventListener('click', restartGame);

        // initialise game
        restartGame();

        // optional: prevent context menu on canvases
        boardCanvas.addEventListener('contextmenu', e => e.preventDefault());
        nextCanvas.addEventListener('contextmenu', e => e.preventDefault());

        // make sure focus stays (no page scroll)
        document.body.addEventListener('keydown', (e) => {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
        });
    })();
</script>
</body>
</html>