<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>chrono mandala Â· time-woven geometry</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #0f0b1a;
            overflow: hidden;
            font-family: 'Inter', 'Segoe UI', system-ui, sans-serif;
        }
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #overlay {
            position: absolute;
            bottom: 32px;
            left: 32px;
            z-index: 20;
            background: rgba(16, 14, 26, 0.65);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(200, 170, 255, 0.25);
            border-radius: 60px;
            padding: 14px 30px;
            color: #e8deff;
            font-weight: 300;
            font-size: 1rem;
            letter-spacing: 0.4px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.6);
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 14px;
        }
        #overlay .emblem {
            color: #c5aaff;
            font-size: 1.6rem;
            line-height: 1;
            filter: drop-shadow(0 0 8px #a07dff);
        }
        #era-badge {
            position: absolute;
            bottom: 32px;
            right: 32px;
            z-index: 20;
            background: rgba(20, 16, 32, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(210, 170, 250, 0.4);
            border-radius: 50px;
            padding: 12px 28px;
            color: #f0e2ff;
            font-size: 1.1rem;
            font-weight: 400;
            display: flex;
            align-items: center;
            gap: 14px;
            box-shadow: 0 15px 30px rgba(0,0,0,0.5);
            pointer-events: none;
        }
        .era-marker {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #c49aff;
            box-shadow: 0 0 20px #b183ff;
            animation: glow 2s infinite alternate;
        }
        @keyframes glow {
            0% { opacity: 0.7; box-shadow: 0 0 10px #b183ff; }
            100% { opacity: 1; box-shadow: 0 0 25px #dbb5ff; }
        }
        .controls {
            position: absolute;
            top: 32px;
            right: 32px;
            z-index: 30;
            display: flex;
            gap: 14px;
        }
        button {
            background: rgba(26, 20, 40, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(170, 130, 250, 0.45);
            color: #d9c9ff;
            padding: 12px 26px;
            border-radius: 50px;
            font-size: 0.95rem;
            font-weight: 400;
            cursor: pointer;
            transition: all 0.2s;
            letter-spacing: 0.4px;
        }
        button:hover {
            background: rgba(80, 50, 150, 0.6);
            border-color: #c7aaff;
            color: white;
            box-shadow: 0 0 28px #8f6cff66;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="overlay">
        <span class="emblem">â—‰</span> chrono mandala Â· 4 eras Â· temporal morph
    </div>
    
    <div id="era-badge">
        <span class="era-marker"></span>
        <span id="era-name">dawn era</span>
    </div>
    
    <div class="controls">
        <button id="morph-btn">ğŸŒ€ morph era</button>
        <button id="freeze-btn">â¸ freeze time</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        //  CHRONO MANDALA
        //  concept: a geometric mandala that transforms through four distinct
        //  "eras" (dawn, solar, lunar, cosmic). each era has unique shape,
        //  color harmony, and rotation logic. the morph is smooth, using
        //  vertex shader style but done via CPU interpolation for clarity.
        //  no basic shapes â€“ intricate wireframe + glass spheres + energy lines.
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0720);
        scene.fog = new THREE.FogExp2(0x0a0720, 0.008);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(22, 10, 28);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.25;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.7;
        controls.enableZoom = true;
        controls.maxPolarAngle = Math.PI / 2.2;
        controls.target.set(0, 1, 0);

        // --- lighting ---
        const ambient = new THREE.AmbientLight(0x404072);
        scene.add(ambient);

        const light1 = new THREE.PointLight(0x9f7aff, 1.4, 45);
        light1.position.set(7, 10, 12);
        scene.add(light1);

        const light2 = new THREE.PointLight(0xff8a9f, 1.0, 45);
        light2.position.set(-9, 5, 14);
        scene.add(light2);

        const backLight = new THREE.PointLight(0x5d8cff, 0.9, 60);
        backLight.position.set(0, 0, -25);
        scene.add(backLight);

        // distant stars
        const starGeo = new THREE.BufferGeometry();
        const starCount = 2200;
        const starPos = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount; i++) {
            const r = 80 + Math.random() * 70;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            starPos[i*3] = Math.sin(phi) * Math.cos(theta) * r;
            starPos[i*3+1] = Math.sin(phi) * Math.sin(theta) * r;
            starPos[i*3+2] = Math.cos(phi) * r;
        }
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const starMat = new THREE.PointsMaterial({ color: 0xb8aaee, size: 0.2, transparent: true, blending: THREE.AdditiveBlending });
        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);

        // --- core data: mandala group ---
        const mandalaGroup = new THREE.Group();
        scene.add(mandalaGroup);

        // we'll have multiple layers: outer ring, middle ring, inner core, floating orbs
        let outerRingLines, middleRingLines, innerRingLines, coreSpheres, energyRibbons;
        
        // store geometry targets for morphing
        const morphTargets = {
            dawn: [],
            solar: [],
            lunar: [],
            cosmic: []
        };

        // current era index (0-3)
        let currentEra = 0; // dawn
        const eraNames = ["dawn era", "solar era", "lunar era", "cosmic era"];
        let morphProgress = 0.0; // 0..1 towards next era
        let morphSpeed = 0.002;
        let frozen = false;

        // UI elements
        const eraNameEl = document.getElementById('era-name');
        const morphBtn = document.getElementById('morph-btn');
        const freezeBtn = document.getElementById('freeze-btn');

        morphBtn.addEventListener('click', () => {
            if (!frozen) {
                // advance to next era
                currentEra = (currentEra + 1) % 4;
                eraNameEl.textContent = eraNames[currentEra];
                morphProgress = 0.0; // start morph cycle
            }
        });

        freezeBtn.addEventListener('click', () => {
            frozen = !frozen;
            freezeBtn.innerHTML = frozen ? 'â–¶ resume' : 'â¸ freeze time';
        });

        // --- generate mandala components ---
        function createMandala() {
            // outer ring: 32 points, complex wave
            const outerPoints = 64;
            const outerPositions = [];
            for (let i = 0; i < outerPoints; i++) {
                const t = i / outerPoints * Math.PI * 2;
                // base circle with modulation
                const r = 8.0 + Math.sin(t * 5) * 1.5;
                const x = Math.cos(t) * r;
                const y = Math.sin(t * 2) * 1.2;
                const z = Math.sin(t) * r * 0.6;
                outerPositions.push(x, y, z);
            }
            
            const outerGeo = new THREE.BufferGeometry();
            outerGeo.setAttribute('position', new THREE.Float32BufferAttribute(outerPositions, 3));
            const outerMat = new THREE.LineBasicMaterial({ color: 0xffaa88, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending });
            outerRingLines = new THREE.LineLoop(outerGeo, outerMat);
            mandalaGroup.add(outerRingLines);

            // middle ring: 48 points, double wave
            const middlePoints = 48;
            const middlePositions = [];
            for (let i = 0; i < middlePoints; i++) {
                const t = i / middlePoints * Math.PI * 2;
                const r = 5.5 + Math.cos(t * 7) * 1.2;
                const x = Math.cos(t) * r;
                const y = Math.sin(t * 3) * 1.5;
                const z = Math.cos(t * 2) * r * 0.5;
                middlePositions.push(x, y, z);
            }
            const middleGeo = new THREE.BufferGeometry();
            middleGeo.setAttribute('position', new THREE.Float32BufferAttribute(middlePositions, 3));
            const middleMat = new THREE.LineBasicMaterial({ color: 0xaaccff, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending });
            middleRingLines = new THREE.LineLoop(middleGeo, middleMat);
            mandalaGroup.add(middleRingLines);

            // inner ring: 24 points, tight knot
            const innerPoints = 32;
            const innerPositions = [];
            for (let i = 0; i < innerPoints; i++) {
                const t = i / innerPoints * Math.PI * 2;
                const r = 3.2 + Math.sin(t * 9) * 0.7;
                const x = Math.cos(t) * r;
                const y = Math.sin(t * 4) * 0.8;
                const z = Math.sin(t * 5) * 1.2;
                innerPositions.push(x, y, z);
            }
            const innerGeo = new THREE.BufferGeometry();
            innerGeo.setAttribute('position', new THREE.Float32BufferAttribute(innerPositions, 3));
            const innerMat = new THREE.LineBasicMaterial({ color: 0xffccaa, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending });
            innerRingLines = new THREE.LineLoop(innerGeo, innerMat);
            mandalaGroup.add(innerRingLines);

            // core spheres: 7 small glowing orbs
            coreSpheres = [];
            const coreGroup = new THREE.Group();
            for (let j = 0; j < 7; j++) {
                const angle = (j / 7) * Math.PI * 2;
                const rad = 1.8;
                const x = Math.cos(angle) * rad;
                const y = Math.sin(angle * 2) * 0.9;
                const z = Math.sin(angle) * rad * 0.5;
                
                const sphereGeo = new THREE.SphereGeometry(0.4, 16, 16);
                const sphereMat = new THREE.MeshStandardMaterial({
                    color: 0xffaa99,
                    emissive: 0x442200,
                    roughness: 0.2,
                    metalness: 0.1
                });
                const sphere = new THREE.Mesh(sphereGeo, sphereMat);
                sphere.position.set(x, y, z);
                coreGroup.add(sphere);
                coreSpheres.push(sphere);
            }
            mandalaGroup.add(coreGroup);

            // energy ribbons (floating curves)
            const ribbonPoints = [];
            for (let k = 0; k < 5; k++) {
                const pts = [];
                for (let p = 0; p < 20; p++) {
                    const tt = p / 19 * Math.PI * 2;
                    const radius = 6 + k * 0.4;
                    const x = Math.cos(tt + k) * radius;
                    const y = Math.sin(tt * 2 + k) * 2.5;
                    const z = Math.sin(tt + k*2) * radius * 0.7;
                    pts.push(new THREE.Vector3(x, y, z));
                }
                const geo = new THREE.BufferGeometry().setFromPoints(pts);
                const mat = new THREE.LineBasicMaterial({ color: 0x99ccff, transparent: true, opacity: 0.2 });
                const line = new THREE.Line(geo, mat);
                mandalaGroup.add(line);
            }
        }

        createMandala();

        // store original positions for later morphing? we'll generate target configurations per era.
        // For simplicity, we'll dynamically adjust colors and rotations based on era.
        // But to show morph, we'll manipulate line geometry points in animation loop.

        // we'll rebuild line geometries with different parameters based on era
        function applyEraMorph(era, progress) {
            // progress is blend between current and next (0..1)
            // for simplicity, we adjust colors, emissive, and rotations in animation.
            // more complex morph could involve actual vertex changes, but we'll keep it stylized.
            
            const eraColors = [
                [0xffaa88, 0xaaccff, 0xffccaa], // dawn
                [0xffdd44, 0xffaa33, 0xff8844], // solar
                [0xaaddff, 0x88aaff, 0xcc99ff], // lunar
                [0xcc88ff, 0xaa88ff, 0x8a6cff]  // cosmic
            ];
            
            const colors = eraColors[era];
            if (outerRingLines) {
                outerRingLines.material.color.setHex(colors[0]);
                middleRingLines.material.color.setHex(colors[1]);
                innerRingLines.material.color.setHex(colors[2]);
            }
            
            // adjust sphere colors
            coreSpheres.forEach((s, idx) => {
                const hue = (era * 0.1 + idx * 0.03) % 1.0;
                s.material.color.setHSL(hue, 0.9, 0.6);
                s.material.emissive.setHSL(hue, 0.8, 0.15);
            });
        }

        // animation variables
        const clock = new THREE.Clock();
        let eraCycle = 0;

        function animate() {
            const delta = clock.getDelta();
            const elapsed = performance.now() / 1000;

            if (!frozen) {
                // slowly morph through eras automatically, but also allow button
                morphProgress += morphSpeed;
                if (morphProgress >= 1.0) {
                    morphProgress = 0.0;
                    currentEra = (currentEra + 1) % 4;
                    eraNameEl.textContent = eraNames[currentEra];
                }
            }
            
            // apply current era with smooth blend (just color for now)
            applyEraMorph(currentEra, morphProgress);
            
            // animate rotation and floating motion
            mandalaGroup.rotation.y += 0.001;
            mandalaGroup.rotation.x += 0.0005;
            
            // individual sphere waltz
            coreSpheres.forEach((sphere, i) => {
                sphere.position.x += Math.sin(elapsed * 2 + i) * 0.002;
                sphere.position.y += Math.cos(elapsed * 1.5 + i) * 0.002;
                sphere.position.z += Math.sin(elapsed * 1.8 + i) * 0.002;
            });

            // star rotation
            stars.rotation.y += 0.00015;

            controls.update();
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        animate();

        // resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // subtle light shifts
        setInterval(() => {
            const t = performance.now() / 2000;
            light1.color.setHSL(0.68 + Math.sin(t)*0.06, 0.8, 0.6);
            light2.color.setHSL(0.92 + Math.cos(t*1.3)*0.05, 0.9, 0.6);
        }, 200);
    </script>
</body>
</html>